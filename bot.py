import os
import io
import asyncio
import smtplib
from datetime import datetime
from email.mime.text import MIMEText
from typing import Dict, Optional

from dotenv import load_dotenv

from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
)

from openai import OpenAI

# =========================
# ENV
# =========================
load_dotenv()

TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
ASSISTANT_ID = os.getenv("ASSISTANT_ID")

OWNER_TELEGRAM_ID = os.getenv("OWNER_TELEGRAM_ID")  # –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤–ª–∞–¥–µ–ª—å—Ü—É
LEAD_EMAIL_TO = os.getenv("LEAD_EMAIL_TO", "maisondecafe.coffee@gmail.com")

SMTP_HOST = os.getenv("SMTP_HOST")
SMTP_PORT = os.getenv("SMTP_PORT")
SMTP_USER = os.getenv("SMTP_USER")
SMTP_PASS = os.getenv("SMTP_PASS")
SMTP_FROM = os.getenv("SMTP_FROM", SMTP_USER or "")

if not TELEGRAM_TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
if not OPENAI_API_KEY:
    raise RuntimeError("OPENAI_API_KEY –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
if not ASSISTANT_ID:
    raise RuntimeError("ASSISTANT_ID –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

client = OpenAI(api_key=OPENAI_API_KEY)

# =========================
# STATE (IN-MEMORY)
# =========================
user_threads: Dict[str, str] = {}   # user_id -> thread_id
user_lang: Dict[str, str] = {}      # user_id -> lang (ua/ru/en/fr/nl)

lead_states: Dict[str, str] = {}    # user_id -> step: name/phone/email/message
lead_data: Dict[str, Dict[str, str]] = {}  # user_id -> collected fields

# =========================
# I18N (texts + buttons)
# =========================
LANGS = ["ua", "ru", "en", "fr", "nl"]

LANG_LABELS = {
    "ua": "üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
    "ru": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
    "en": "üá¨üáß English",
    "fr": "üá´üá∑ Fran√ßais",
    "nl": "üá≥üá± Nederlands",
}

# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (–∫–Ω–æ–ø–∫–∏) ‚Äî –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–æ
MENU = {
    "ua": {
        "what": "‚òï –©–æ —Ç–∞–∫–µ Maison de Caf√©?",
        "price": "üí∂ –°–∫—ñ–ª—å–∫–∏ –∫–æ—à—Ç—É—î –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∫–∞–≤‚Äô—è—Ä–Ω—é?",
        "payback": "üìà –û–∫—É–ø–Ω—ñ—Å—Ç—å —ñ –ø—Ä–∏–±—É—Ç–æ–∫",
        "franchise": "ü§ù –£–º–æ–≤–∏ —Ñ—Ä–∞–Ω—à–∏–∑–∏",
        "contacts": "üìû –ö–æ–Ω—Ç–∞–∫—Ç–∏ / –∑–≤‚Äô—è–∑–æ–∫ –∑ –≤–ª–∞—Å–Ω–∏–∫–æ–º",
        "lead": "üìù –ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É",
        "lang": "üåç –ú–æ–≤–∞ / Language",
    },
    "ru": {
        "what": "‚òï –ß—Ç–æ —Ç–∞–∫–æ–µ Maison de Caf√©?",
        "price": "üí∂ –°–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç –æ—Ç–∫—Ä—ã—Ç—å –∫–æ—Ñ–µ–π–Ω—é?",
        "payback": "üìà –û–∫—É–ø–∞–µ–º–æ—Å—Ç—å –∏ –ø—Ä–∏–±—ã–ª—å",
        "franchise": "ü§ù –£—Å–ª–æ–≤–∏—è —Ñ—Ä–∞–Ω—à–∏–∑—ã",
        "contacts": "üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã / —Å–≤—è–∑—å —Å –≤–ª–∞–¥–µ–ª—å—Ü–µ–º",
        "lead": "üìù –û—Å—Ç–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É",
        "lang": "üåç –Ø–∑—ã–∫ / Language",
    },
    "en": {
        "what": "‚òï What is Maison de Caf√©?",
        "price": "üí∂ How much does it cost to open a coffee point?",
        "payback": "üìà Payback & profit",
        "franchise": "ü§ù Franchise terms",
        "contacts": "üìû Contacts / owner",
        "lead": "üìù Leave a request",
        "lang": "üåç Language",
    },
    "fr": {
        "what": "‚òï Qu‚Äôest-ce que Maison de Caf√© ?",
        "price": "üí∂ Combien co√ªte l‚Äôouverture ?",
        "payback": "üìà Rentabilit√© & profit",
        "franchise": "ü§ù Conditions de franchise",
        "contacts": "üìû Contacts / propri√©taire",
        "lead": "üìù Laisser une demande",
        "lang": "üåç Langue / Language",
    },
    "nl": {
        "what": "‚òï Wat is Maison de Caf√©?",
        "price": "üí∂ Wat kost het om te starten?",
        "payback": "üìà Terugverdientijd & winst",
        "franchise": "ü§ù Franchisevoorwaarden",
        "contacts": "üìû Contact / eigenaar",
        "lead": "üìù Aanvraag achterlaten",
        "lang": "üåç Taal / Language",
    },
}

TEXTS = {
    "ua": {
        "welcome": (
            "–î–æ–±—Ä–∏–π –¥–µ–Ω—å!\n"
            "–ú–µ–Ω–µ –∑–≤–∞—Ç–∏ –ú–∞–∫—Å, —è –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–∏–π –ø–æ–º—ñ—á–Ω–∏–∫ –∫–æ–º–ø–∞–Ω—ñ—ó Maison de Caf√©.\n"
            "–Ø –¥–æ–ø–æ–º–æ–∂—É –≤–∞–º —Ä–æ–∑—ñ–±—Ä–∞—Ç–∏—Å—è —É –≤—Å—ñ—Ö –ø–∏—Ç–∞–Ω–Ω—è—Ö, –ø–æ–≤‚Äô—è–∑–∞–Ω–∏—Ö –∑ –Ω–∞—à–∏–º–∏ –∫–∞–≤‚Äô—è—Ä–Ω—è–º–∏ —Å–∞–º–æ–æ–±—Å–ª—É–≥–æ–≤—É–≤–∞–Ω–Ω—è, –∑–∞–ø—É—Å–∫–æ–º —ñ —É–º–æ–≤–∞–º–∏ —Å–ø—ñ–≤–ø—Ä–∞—Ü—ñ.\n"
            "–©–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏, –ø—ñ–¥–∫–∞–∂—ñ—Ç—å, –±—É–¥—å –ª–∞—Å–∫–∞, —è–∫ –≤–∞—Å –∑–≤–∞—Ç–∏?"
        ),
        "choose_lang": "üåç –û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É:",
        "lang_set": "‚úÖ –ú–æ–≤—É –∑–º—ñ–Ω–µ–Ω–æ: {lang}.",
        "lead_start": "üìù –ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É.\n\n–ö—Ä–æ–∫ 1/4: –ù–∞–ø–∏—à—ñ—Ç—å –≤–∞—à–µ —ñ–º‚Äô—è —Ç–∞ –ø—Ä—ñ–∑–≤–∏—â–µ.",
        "lead_phone": "–ö—Ä–æ–∫ 2/4: –ù–∞–ø–∏—à—ñ—Ç—å –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É.",
        "lead_email": "–ö—Ä–æ–∫ 3/4: –ù–∞–ø–∏—à—ñ—Ç—å –≤–∞—à email.",
        "lead_msg": "–ö—Ä–æ–∫ 4/4: –ö–æ—Ä–æ—Ç–∫–æ –æ–ø–∏—à—ñ—Ç—å –≤–∞—à –∑–∞–ø–∏—Ç (1‚Äì2 —Ä–µ—á–µ–Ω–Ω—è).",
        "lead_done": (
            "–î—è–∫—É—î–º–æ! –ó–∞—è–≤–∫—É –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ. –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –∑–≤‚Äô—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏ –ø—Ä–æ—Ç—è–≥–æ–º 24 –≥–æ–¥–∏–Ω.\n\n"
            "{email_note}"
        ),
        "voice_fail": "–ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ –≥–æ–ª–æ—Å. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
        "generic_error": "‚ö†Ô∏è –°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
        "contacts_text": (
            "–ó–≤‚Äô—è–∑–∞—Ç–∏—Å—è –∑ Maison de Caf√© –º–æ–∂–Ω–∞ —Ç–∞–∫:\n\n"
            "‚Ä¢ Email: maisondecafe.coffee@gmail.com\n"
            "‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: +32 470 600 806\n"
            "‚Ä¢ Telegram-–∫–∞–Ω–∞–ª: https://t.me/maisondecafe\n\n"
            "–Ø–∫—â–æ —Ö–æ—á–µ—Ç–µ ‚Äî –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ó–∞–ª–∏—à–∏—Ç–∏ –∑–∞—è–≤–∫—É¬ª, —ñ –º–µ–Ω–µ–¥–∂–µ—Ä –∑–≤‚Äô—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏ –ø—Ä–æ—Ç—è–≥–æ–º 24 –≥–æ–¥–∏–Ω."
        ),
    },
    "ru": {
        "welcome": (
            "–î–æ–±—Ä—ã–π –¥–µ–Ω—å!\n"
            "–ú–µ–Ω—è –∑–æ–≤—É—Ç –ú–∞–∫—Å, —è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –∫–æ–º–ø–∞–Ω–∏–∏ Maison de Caf√©.\n"
            "–Ø –ø–æ–º–æ–≥—É –≤–∞–º —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤–æ –≤—Å–µ—Ö –≤–æ–ø—Ä–æ—Å–∞—Ö, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∞—à–∏–º–∏ –∫–æ—Ñ–µ–π–Ω—è–º–∏ —Å–∞–º–æ–æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è, –∑–∞–ø—É—Å–∫–æ–º –∏ —É—Å–ª–æ–≤–∏—è–º–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–∞.\n"
            "–ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, –ø–æ–¥—Å–∫–∞–∂–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–∞–∫ –≤–∞—Å –∑–æ–≤—É—Ç?"
        ),
        "choose_lang": "üåç –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        "lang_set": "‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {lang}.",
        "lead_start": "üìù –û—Å—Ç–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É.\n\n–®–∞–≥ 1/4: –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é.",
        "lead_phone": "–®–∞–≥ 2/4: –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞.",
        "lead_email": "–®–∞–≥ 3/4: –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à email.",
        "lead_msg": "–®–∞–≥ 4/4: –ö–æ—Ä–æ—Ç–∫–æ –æ–ø–∏—à–∏—Ç–µ –∑–∞–ø—Ä–æ—Å (1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è).",
        "lead_done": (
            "–°–ø–∞—Å–∏–±–æ! –ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞. –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ 24 —á–∞—Å–æ–≤.\n\n"
            "{email_note}"
        ),
        "voice_fail": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",
        "generic_error": "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.",
        "contacts_text": (
            "–°–≤—è–∑–∞—Ç—å—Å—è —Å Maison de Caf√© –º–æ–∂–Ω–æ —Ç–∞–∫:\n\n"
            "‚Ä¢ Email: maisondecafe.coffee@gmail.com\n"
            "‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: +32 470 600 806\n"
            "‚Ä¢ Telegram-–∫–∞–Ω–∞–ª: https://t.me/maisondecafe\n\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ ‚Äî –Ω–∞–∂–º–∏—Ç–µ ¬´–û—Å—Ç–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É¬ª, –∏ –º–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ 24 —á–∞—Å–æ–≤."
        ),
    },
    "en": {
        "welcome": (
            "Hello!\n"
            "My name is Max, I‚Äôm the virtual assistant of Maison de Caf√©.\n"
            "I‚Äôll help you with everything related to our self-service coffee points, launch costs, and partnership terms.\n"
            "To continue, may I know your name?"
        ),
        "choose_lang": "üåç Choose a language:",
        "lang_set": "‚úÖ Language set: {lang}.",
        "lead_start": "üìù Leave a request.\n\nStep 1/4: Please type your first & last name.",
        "lead_phone": "Step 2/4: Please type your phone number.",
        "lead_email": "Step 3/4: Please type your email.",
        "lead_msg": "Step 4/4: Briefly describe your request (1‚Äì2 sentences).",
        "lead_done": "Thank you! Request sent. Our manager will contact you within 24 hours.\n\n{email_note}",
        "voice_fail": "I couldn't understand the voice message. Please try again.",
        "generic_error": "‚ö†Ô∏è Something went wrong. Please try again.",
        "contacts_text": (
            "You can contact Maison de Caf√© via:\n\n"
            "‚Ä¢ Email: maisondecafe.coffee@gmail.com\n"
            "‚Ä¢ Phone: +32 470 600 806\n"
            "‚Ä¢ Telegram channel: https://t.me/maisondecafe\n\n"
            "If you want ‚Äî tap ‚ÄúLeave a request‚Äù and a manager will contact you within 24 hours."
        ),
    },
    "fr": {
        "welcome": (
            "Bonjour !\n"
            "Je m‚Äôappelle Max, assistant virtuel de Maison de Caf√©.\n"
            "Je peux vous aider sur le lancement, les co√ªts et les conditions de partenariat.\n"
            "Pour continuer, comment vous appelez-vous ?"
        ),
        "choose_lang": "üåç Choisissez la langue :",
        "lang_set": "‚úÖ Langue s√©lectionn√©e : {lang}.",
        "lead_start": "üìù Laisser une demande.\n\n√âtape 1/4 : votre nom et pr√©nom.",
        "lead_phone": "√âtape 2/4 : votre num√©ro de t√©l√©phone.",
        "lead_email": "√âtape 3/4 : votre email.",
        "lead_msg": "√âtape 4/4 : d√©crivez bri√®vement votre demande (1‚Äì2 phrases).",
        "lead_done": "Merci ! Demande envoy√©e. Un manager vous contactera sous 24h.\n\n{email_note}",
        "voice_fail": "Je n‚Äôai pas pu comprendre le message vocal. R√©essayez.",
        "generic_error": "‚ö†Ô∏è Une erreur est survenue. R√©essayez.",
        "contacts_text": (
            "Vous pouvez contacter Maison de Caf√© via :\n\n"
            "‚Ä¢ Email : maisondecafe.coffee@gmail.com\n"
            "‚Ä¢ T√©l√©phone : +32 470 600 806\n"
            "‚Ä¢ Canal Telegram : https://t.me/maisondecafe\n\n"
            "Si vous voulez ‚Äî cliquez ¬´ Laisser une demande ¬ª et un manager vous contactera sous 24h."
        ),
    },
    "nl": {
        "welcome": (
            "Hallo!\n"
            "Ik ben Max, de virtuele assistent van Maison de Caf√©.\n"
            "Ik help je met vragen over startkosten, winst en franchisevoorwaarden.\n"
            "Om verder te gaan: hoe heet je?"
        ),
        "choose_lang": "üåç Kies een taal:",
        "lang_set": "‚úÖ Taal ingesteld: {lang}.",
        "lead_start": "üìù Aanvraag achterlaten.\n\nStap 1/4: Typ je voor- en achternaam.",
        "lead_phone": "Stap 2/4: Typ je telefoonnummer.",
        "lead_email": "Stap 3/4: Typ je e-mail.",
        "lead_msg": "Stap 4/4: Beschrijf kort je vraag (1‚Äì2 zinnen).",
        "lead_done": "Bedankt! Aanvraag verzonden. We nemen binnen 24 uur contact op.\n\n{email_note}",
        "voice_fail": "Ik kon het spraakbericht niet begrijpen. Probeer het opnieuw.",
        "generic_error": "‚ö†Ô∏è Er ging iets mis. Probeer het opnieuw.",
        "contacts_text": (
            "Contact opnemen met Maison de Caf√© kan via:\n\n"
            "‚Ä¢ E-mail: maisondecafe.coffee@gmail.com\n"
            "‚Ä¢ Telefoon: +32 470 600 806\n"
            "‚Ä¢ Telegram-kanaal: https://t.me/maisondecafe\n\n"
            "Wil je ‚Äî klik ‚ÄúAanvraag achterlaten‚Äù, dan nemen we binnen 24 uur contact op."
        ),
    },
}

ASSISTANT_LANG_INSTRUCTIONS = {
    "ua": "–í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é. –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –ø–∏—à–µ —ñ–Ω—à–æ—é –º–æ–≤–æ—é ‚Äî –≤—Å–µ –æ–¥–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é.",
    "ru": "–û—Ç–≤–µ—á–∞–π –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.",
    "en": "Respond in English.",
    "fr": "R√©ponds en fran√ßais.",
    "nl": "Antwoord in het Nederlands.",
}

# =========================
# HELPERS
# =========================
def get_lang(user_id: str) -> str:
    return user_lang.get(user_id, "ua")  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —É–∫—Ä–∞–∏–Ω—Å–∫–∏–π

def t(user_id: str, key: str) -> str:
    lang = get_lang(user_id)
    return TEXTS.get(lang, TEXTS["ua"]).get(key, TEXTS["ua"].get(key, ""))

def mk_main_keyboard(lang: str) -> ReplyKeyboardMarkup:
    m = MENU[lang]
    kb = [
        [m["what"], m["price"]],
        [m["payback"], m["franchise"]],
        [m["contacts"], m["lead"]],
        [m["lang"]],
    ]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)

def mk_lang_keyboard() -> ReplyKeyboardMarkup:
    kb = [
        [LANG_LABELS["ua"], LANG_LABELS["ru"]],
        [LANG_LABELS["en"], LANG_LABELS["fr"]],
        [LANG_LABELS["nl"]],
    ]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True, one_time_keyboard=True)

def parse_lang_choice(text: str) -> Optional[str]:
    for code, label in LANG_LABELS.items():
        if text.strip() == label:
            return code
    return None

def is_lang_button(text: str) -> bool:
    text = (text or "").strip()
    return text in {MENU[l]["lang"] for l in LANGS}

def is_lead_button(text: str) -> bool:
    text = (text or "").strip()
    return text in {MENU[l]["lead"] for l in LANGS}

def is_contacts_button(text: str) -> bool:
    text = (text or "").strip()
    return text in {MENU[l]["contacts"] for l in LANGS}

def ensure_thread(user_id: str) -> str:
    if user_id not in user_threads:
        thread = client.beta.threads.create()
        user_threads[user_id] = thread.id
    return user_threads[user_id]

def smtp_configured() -> bool:
    return bool(SMTP_HOST and SMTP_PORT and SMTP_USER and SMTP_PASS and SMTP_FROM and LEAD_EMAIL_TO)

def send_lead_email(subject: str, body: str) -> bool:
    if not smtp_configured():
        return False

    try:
        msg = MIMEText(body, "plain", "utf-8")
        msg["Subject"] = subject
        msg["From"] = SMTP_FROM
        msg["To"] = LEAD_EMAIL_TO

        with smtplib.SMTP(SMTP_HOST, int(SMTP_PORT)) as server:
            server.starttls()
            server.login(SMTP_USER, SMTP_PASS)
            server.sendmail(SMTP_FROM, [LEAD_EMAIL_TO], msg.as_string())
        return True
    except Exception as e:
        print("SMTP ERROR:", repr(e))
        return False

# =========================
# /start
# =========================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)

    # default language UA
    if user_id not in user_lang:
        user_lang[user_id] = "ua"

    # create thread for user
    ensure_thread(user_id)

    lang = get_lang(user_id)
    await update.message.reply_text(
        TEXTS[lang]["welcome"],
        reply_markup=mk_main_keyboard(lang),
    )

# =========================
# LANGUAGE FLOW
# =========================
async def show_language_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    await update.message.reply_text(t(user_id, "choose_lang"), reply_markup=mk_lang_keyboard())

async def set_language(update: Update, context: ContextTypes.DEFAULT_TYPE, lang_code: str):
    user_id = str(update.effective_user.id)
    user_lang[user_id] = lang_code

    await update.message.reply_text(
        t(user_id, "lang_set").format(lang=LANG_LABELS[lang_code]),
        reply_markup=mk_main_keyboard(lang_code),
    )

# =========================
# LEAD FORM FLOW
# =========================
async def start_lead_form(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    lead_states[user_id] = "name"
    lead_data[user_id] = {}

    await update.message.reply_text(
        t(user_id, "lead_start"),
        reply_markup=mk_main_keyboard(get_lang(user_id)),
    )

async def handle_lead_form(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    lang = get_lang(user_id)

    step = lead_states.get(user_id)
    text = (update.message.text or "").strip()

    if not step:
        return False

    if step == "name":
        lead_data[user_id]["name"] = text
        lead_states[user_id] = "phone"
        await update.message.reply_text(TEXTS[lang]["lead_phone"], reply_markup=mk_main_keyboard(lang))
        return True

    if step == "phone":
        lead_data[user_id]["phone"] = text
        lead_states[user_id] = "email"
        await update.message.reply_text(TEXTS[lang]["lead_email"], reply_markup=mk_main_keyboard(lang))
        return True

    if step == "email":
        lead_data[user_id]["email"] = text
        lead_states[user_id] = "message"
        await update.message.reply_text(TEXTS[lang]["lead_msg"], reply_markup=mk_main_keyboard(lang))
        return True

    if step == "message":
        lead_data[user_id]["message"] = text
        lead_states.pop(user_id, None)

        # Prepare lead payload
        username = update.effective_user.username or ""
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        payload = (
            f"Telegram user_id: {user_id}\n"
            f"Username: @{username}\n"
            f"–Ü–º'—è/–ü—Ä—ñ–∑–≤–∏—â–µ: {lead_data[user_id].get('name','')}\n"
            f"–¢–µ–ª–µ—Ñ–æ–Ω: {lead_data[user_id].get('phone','')}\n"
            f"Email: {lead_data[user_id].get('email','')}\n"
            f"–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: {lead_data[user_id].get('message','')}\n"
            f"–ß–∞—Å: {now}\n"
        )

        # Notify owner in Telegram
        owner_notified = False
        if OWNER_TELEGRAM_ID:
            try:
                await context.bot.send_message(chat_id=int(OWNER_TELEGRAM_ID), text=payload)
                owner_notified = True
            except Exception as e:
                print("OWNER TG NOTIFY ERROR:", repr(e))

        # Optional email
        email_sent = send_lead_email("Maison de Caf√© ‚Äî New lead", payload)

        if email_sent:
            email_note = "‚úÖ Email-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ."
        else:
            email_note = "–ü—Ä–∏–º—ñ—Ç–∫–∞: –≤—ñ–¥–ø—Ä–∞–≤–∫–∞ –Ω–∞ email –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–∞ (SMTP). –°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–ª–∞—Å–Ω–∏–∫—É –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram." if owner_notified else "–ü—Ä–∏–º—ñ—Ç–∫–∞: email (SMTP) –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ, —ñ Telegram-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤–ª–∞—Å–Ω–∏–∫—É –Ω–µ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ."

        await update.message.reply_text(
            TEXTS[lang]["lead_done"].format(email_note=email_note),
            reply_markup=mk_main_keyboard(lang),
        )

        lead_data.pop(user_id, None)
        return True

    return False

# =========================
# ASSISTANT (text)
# =========================
async def ask_assistant(user_id: str, user_text: str) -> str:
    thread_id = ensure_thread(user_id)
    lang = get_lang(user_id)

    client.beta.threads.messages.create(
        thread_id=thread_id,
        role="user",
        content=user_text,
    )

    run = client.beta.threads.runs.create(
        thread_id=thread_id,
        assistant_id=ASSISTANT_ID,
        instructions=ASSISTANT_LANG_INSTRUCTIONS.get(lang, ASSISTANT_LANG_INSTRUCTIONS["ua"]),
    )

    # wait completion
    while True:
        run_status = client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run.id)
        if run_status.status == "completed":
            break
        if run_status.status in ["failed", "cancelled", "expired"]:
            return ""
        await asyncio.sleep(1)

    messages = client.beta.threads.messages.list(thread_id=thread_id)
    if not messages.data:
        return ""

    return messages.data[0].content[0].text.value

# =========================
# TEXT HANDLER
# =========================
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    lang = get_lang(user_id)
    text = (update.message.text or "").strip()

    # Lead form step processing (priority)
    if user_id in lead_states:
        handled = await handle_lead_form(update, context)
        if handled:
            return

    # Open language menu
    if is_lang_button(text):
        await show_language_menu(update, context)
        return

    # Choose language
    chosen = parse_lang_choice(text)
    if chosen:
        await set_language(update, context, chosen)
        return

    # Lead form start
    if is_lead_button(text):
        await start_lead_form(update, context)
        return

    # Contacts (static)
    if is_contacts_button(text):
        await update.message.reply_text(TEXTS[lang]["contacts_text"], reply_markup=mk_main_keyboard(lang))
        return

    # Otherwise -> assistant
    try:
        ai_reply = await ask_assistant(user_id, text)
        if not ai_reply:
            await update.message.reply_text(TEXTS[lang]["generic_error"], reply_markup=mk_main_keyboard(lang))
            return
        await update.message.reply_text(ai_reply, reply_markup=mk_main_keyboard(lang))
    except Exception as e:
        print("ASSISTANT ERROR:", repr(e))
        await update.message.reply_text(TEXTS[lang]["generic_error"], reply_markup=mk_main_keyboard(lang))

# =========================
# VOICE HANDLER
# =========================
async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    lang = get_lang(user_id)

    try:
        voice = update.message.voice
        tg_file = await context.bot.get_file(voice.file_id)

        buf = io.BytesIO()
        await tg_file.download_to_memory(out=buf)
        buf.seek(0)
        buf.name = "voice.ogg"

        transcript = client.audio.transcriptions.create(
            model="gpt-4o-mini-transcribe",
            file=buf,
        )
        user_text = (transcript.text or "").strip()

        if not user_text:
            await update.message.reply_text(TEXTS[lang]["voice_fail"], reply_markup=mk_main_keyboard(lang))
            return

        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª –≤ –ª–∏–¥-—Ñ–æ—Ä–º–µ ‚Äî —Å—á–∏—Ç–∞–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç –∫–∞–∫ –≤–≤–æ–¥ –≤ –ª–∏–¥-—Ñ–æ—Ä–º—É
        if user_id in lead_states:
            # –ü–æ–¥–º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ —Ç–µ–∫—Å—Ç
            update.message.text = user_text
            await handle_message(update, context)
            return

        # –æ–±—ã—á–Ω—ã–π –ø–æ—Ç–æ–∫: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç –≤ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç
        ai_reply = await ask_assistant(user_id, user_text)
        if not ai_reply:
            await update.message.reply_text(TEXTS[lang]["generic_error"], reply_markup=mk_main_keyboard(lang))
            return

        await update.message.reply_text(ai_reply, reply_markup=mk_main_keyboard(lang))

    except Exception as e:
        print("VOICE ERROR:", repr(e))
        await update.message.reply_text(TEXTS[lang]["generic_error"], reply_markup=mk_main_keyboard(lang))

# =========================
# ENTRYPOINT
# =========================
def main():
    print("üöÄ Bot is starting...")

    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    application.add_handler(CommandHandler("start", start))

    # voice must be BEFORE generic text (not strictly required, –Ω–æ —Ç–∞–∫ –Ω–∞–¥–µ–∂–Ω–µ–µ)
    application.add_handler(MessageHandler(filters.VOICE, handle_voice))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    application.run_polling()

if __name__ == "__main__":
    main()
